---
title: temple
date: '2022/12/15'
tags: ['资讯', 'event loop']
draft: true
summary: JS 的异步机制一探;
---

<TOCInline toc={props.toc} asDisclosure toHeading={3} />

## 2022/12/15

## 每周资讯 - 第`149`期

### 1. JS 的异步机制一探

#### JavaScript 异步原理

对于 FEer 来说，JavaScript 是单线程，同一时间只能执行一个任务，这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。对于计算类型的任务，需要使用到 CPU，就只能等待任务执行完毕；但是对于很多时候 CPU 都是闲着的，比如在执行 IO 操作（输入输出），ajax 请求，文件读写等，这些操作 CPU 完全可以不管 IO 操作，可以继续往下执行其他任务。异步机制就是为了解决这个问题，这种机制在 JavaScript 内部采用的事件循环机制（Event Loop）。

> **JavaScript 是单线程，同一时间只能执行一个任务。**
> 当然，在浏览器上还是有可以开启多个线程的解决方案 Web Worker，但是它只能执行计算类的操作，无法操作 DOM。

#### 事件循环

一个事件循环，有一个 Event 的队列（所有发生的 event 都存储在这里——下图中称为任务队列 Task Queue）。还有一个 Event Loop，它不断地将这些 event 从队列中取出，并调用事件中的回调（call stack 会执行所有的回调）。API 是用于处理异步函数的 API，比如说处理等待来自客户端或 server 的响应，读取本地文件，定时器 settimeout 等。

在此流程中，所有 function call 首先进入 call stack，然后通过 API 执行异步任务。当异步任务完成后，callback 进入任务队列，然后再次进入 call stack。当任务执行完之后，event loop 会再次去 task queue 重复上面的流程。

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9nsZj5INI8dx15O06eZQoFaiald0XJ5qs8X6RctAazwKY9LAmujqO1NEhgh5XgaAtpt4GHTYVcFAA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

#### 任务类型

上面提到了任务队列，在浏览器中，主要分成两种任务：宏任务、微任务。

它们都是通过调用浏览器提供的 API 产生。

以下把浏览器和 Nodejs 中能够生成异步任务的 api 都列出来。

##### 宏任务（macrotask）

- script（整块代码）
- setTimeout
- setInterval
- setImmediate (Node 独有)
- requestAnimationFrame (浏览器独有)
- I/O
- UI rendering (浏览器独有)

##### 微任务（microtask）

- process.nextTick (Node 独有)
- Promise
- Object.observe
- MutationObserver

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9nsZj5INI8dx15O06eZQoFFzibXM5W27sUyuIKJmLklFiaEzOaJeTLTuGtSTsmOLZoible8R4v9qhZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

一个事件循环完整执行过程，可以参考[`《带你了解事件循环机制(Event Loop)》`](https://blog.csdn.net/weixin_52092151/article/details/119788483)

#### JavaScript 异步编程

浏览器中 JavaScript 异步编程的发展可以分为四个阶段

- 回调函数
- Promise
- Generator
- async/await

##### 回调函数

> 回调函数非常简单容易理解和实现，缺点不利于代码的维护和阅读，各个部分之间高度耦合，还会造成回调地狱。

以实现红绿灯为例

<details><summary>代码</summary>

```js
function red() {
  console.log('red')
}

function green() {
  console.log('green')
}

function yellow() {
  console.log('yellow')
}

const task = (timer, light, callback) => {
  setTimout(() => {
    switch (light) {
      case 'red':
        red()
        break
      case 'green':
        green()
        break
      case 'yellow':
        yellow()
        break
    }
    callback()
  }, timer)
}

const work = () => {
  task(3000, 'red', () => {
    task(1000, 'green', () => {
      task(2000, 'yellow', work)
    })
  })
}
work()
```

</details>

#### Promise

> Promise 是为了解决回调地狱才被提出来的，它允许将传统的嵌套回调函数写法转化为链式调用。

<details><summary>代码</summary>

```js
function red() {
  console.log('red')
}

function green() {
  console.log('green')
}

function yellow() {
  console.log('yellow')
}

const task = (timer, light, callback) => {
  setTimout(() => {
    switch (light) {
      case 'red':
        red()
        break
      case 'green':
        green()
        break
      case 'yellow':
        yellow()
        break
    }
    callback()
  }, timer)
}

const work = () => {
  task(3000, 'red', () => {
    task(1000, 'green', () => {
      task(2000, 'yellow', work)
    })
  })
}
work()
```

</details>

##### Generator

> Generator 函数可以暂停执行和恢复执行，同时它还具备两个特性：函数体内的数据转换和错误处理机制。相信很多同学在实际工作中，很少用到 generator，但是了解他可以让我们实现很多有趣的功能。详细介绍可以参考[《什么是 JavaScript generator 以及如何使用它们》](https://zhuanlan.zhihu.com/p/45599048)和[《Generator 函数的含义与用法》](https://www.ruanyifeng.com/blog/2015/04/generator.html)两篇文章。

<details><summary>代码</summary>

```js
const generator = function* () {
  yield promiseLight(3000, 'red')
  yield promiseLight(1000, 'green')
  yield promiseLight(2000, 'yellow')
  yield generator()
}

const generatorObj = generator()
generatorObj.next()
generatorObj.next()
generatorObj.next()
```

</details>

##### async/await

> 这种语法能够让我们以写同步代码的习惯来编程异步代码。Generator 实际就是 async 函数的语法糖。

想更深入学些 async/await 用法，可以参考[《async 函数的含义和用法》](https://www.ruanyifeng.com/blog/2015/05/async.html)

<details><summary>代码</summary>

```js
const asyncTask = async () => {
  await promiseLight(3000, 'red')
  await promiseLight(1000, 'green')
  await promiseLight(2000, 'yellow')
}
asyncTask()
```

</details>

#### 相关文章

- [JS 的异步机制一探](https://mp.weixin.qq.com/s/jfXQgAR6Su8yvwgc24g-Lw)

### 2.

#### 相关文章

## 30 seconds of code

### 目标

### 样例输出:

```js

```

### 参考实现

```js

```

## ts 挑战

###

```ts

```

### 上期答案

####

```ts

```

## 好库推荐
