---
title: 第62期
date: '2021-07-23'
tags: []
draft: false
summary: 和 winter 聊完前端，我总结了这 20 句掏心窝子的话;
---

<TOCInline toc={props.toc} asDisclosure toHeading={3} />

## 2021/07/23

## 每周资讯 - 第`63`期

### 1. 和 winter 聊完前端，我总结了这 20 句掏心窝子的话

因为工作的关系，我和前手机淘宝前端负责人 winter 聊过很多次。winter 很有意思，他是 C++出身，但没走寻常路，机缘巧合，他后来成为了一名前端工程师。现在，他从阿里出来，专职做起了教育。

对于部分前端工程师的困境，我觉得 winter 的回答颇有参考价值。第一，他曾经是一名前端工程师，并且做到了阿里巴巴 P8 级别。第二，他现在是一名教育工作者，工作的原因，他能够更好理解其他工程师的问题。

以下内容是我们聊天关键内容的整理，版权属于 winter（手动狗头）。

1、别再吐槽前端更新快了，比起后端，前端的更新算慢了。你看看后端云原生体系那个图，看完估计你的感觉就是小巫见大巫。整个互联网行业的特点就是“快”，不管是前端、服务端，还是产品、运营，都是跟着互联网的快速迭代不断往前跑。

2、没有什么一劳永逸的东西，你还想着像 20 年前父辈那样慢节奏生活？时代不一样了，行业也不一样了。你得改变工作和学习心态。现在，我习惯叫“爬坡”，就是你每天都得随着技术更迭的浪潮往前走，别停下来。

3、对于工程师，你去和优秀的人聊，他绝对会给你说一个词，“热爱”。你喜欢这件事情，就会在这里投入时间，就会有更多主动性。但如果你本身对这个事情不喜欢，或者无法从中获得成就感和乐趣，这样你就要以超强的意志力去坚持下去。所以，先试着喜欢上你做的事情吧。

4、要想更好地坚持，也要养成一些良好的习惯，比如对于新东西，永远要持有一种开放、拥抱的态度；比如做事的时候，永远要多看看其他优秀的产品是什么样的，要多想一想为什么，而不是只想着做什么；再比如，要时时记得调整自己的心态，无论在做什么事，无论自己喜不喜欢，永远要在其中找到一个自己比较满意的角度，然后调动自己的情绪，把它做好。

5、“两三年后，你希望自己成为一个什么样的前端”，winter 面试的时候特别喜欢问这个问题，但他发现大部分人形容不出来的。在他看来，现在各个大公司里的职级体系以及每个职级的具体要求，其实就是最好的参照标准，因为它们是符合工程上的客观规律的。

6、比如入门级的工程师，要求的就是独立工作的能力；资深工程师，就需要作为项目的核心骨干去解决项目中遇到的各种问题；领域专家，就需要去解决他所负责领域里的所有问题；职能专家，就需要有足够的规划性和前瞻性，能够带领职能往前发展；再往上是阿里定义的资深专家，就需要能够为公司无中生有地做出一件事情，能够为公司创造独有的价值。

7、你可以看到，整个职级体系里面，每个级别的定义都是跟产出强相关的。技术在这里面是一个必要条件，但不是一个充分条件。一个技术上非常厉害的人，在公司里的级别不一定很高，这也是很多人曾疑惑过的问题。其实道理很简单，公司本质上是一个商业活动，它不关心你的技术有多好，它关心的是你能不能把它想要的东西做出来。如果在一个研究机构，或许能评到一个很高的级别，但在商业公司里面，人家看的就是你对项目的产出。

8、不只是前端，很多技术人就是不能理解这一点，或者他知道，但是还没有内化到自己的思考模式中去，这就导致他们对于职场的认知始终处在一个很混沌模糊的状态，凭着本能做事，不知道什么地方看产出，又该怎么看产出，也不知道怎么尽快达成下一个职级的定义和要求。

9、直播的时候，经常有人问，我学历不好怎么办，我年龄大怎么办。遇到这种问题，我特别想推荐他们看看《高效能人士七个习惯》这本书。别过度关注那些自己改变不了的事情，有那时间，你就想想，怎么提升自己的能力，等你技术好了，那些问题都烟消云散了。逻辑就这么简单，为啥就不懂呢？

10、那些不能改变的问题，你关注了又有什么意义呢，那些你能改变的东西，才是帮助你达到下一个级别的关键。所以，很多大佬经常说，“认知很重要”。但我们程序员一听，好家伙，又在给我洗脑，又来虚的。

11、怎么能是虚的呢？思维方式是核心，只有“脑子”变了，行动才能变。认知层面的东西是最牢固、最难改的。即使你在分享的过程中不断地强调，大家听你讲的时候，当时当刻觉得很有道理，但换个场景，可能又回到了自己的固有认知中去。从觉得有道理，到真正把它变成自己的观点、自己的认知，这是一个漫长的过程。而怎么帮助用户缩短这个过程，就是 winter 当前最大的挑战了。

12、WebAssembly 特别有意思，它更像是前端让出了一块空地给其他语言的人，让他们能够进来玩一些前端玩的东西，这是一个邀请的姿势。它可能会引起一些特殊的变化，比如说 C++ 突然就能写前端了，非常值得期待。

13、像 Serverless 这样的技术，其实是服务端本身希望往平台化方向发展的结果。如果你对服务端工程师有所了解，你会发现，他们特别不喜欢做那些非平台化、重复劳动的事情。你还可以去看看每个公司做业务的服务端和做平台的服务端的比例，基本上都是对平台的投入远远大于前者，薪资待遇、公司级别也更高。而且一个很现实的现象是，做业务的都是“小兵”，那些真正的技术大佬，一定是越做越往后延伸的。

14、也正是因为服务端会往平台的方向去延伸，给了 Serverless 大大的发展机会，当然，不管事实如何，Serverless 真正落地，最大的受益人始终是前端。不过，这件事前端再怎么扑腾，最多起到一个推动的作用，最终还得看服务端怎么做，而最终，前端能把自己的触角延伸到什么程度，也取决于服务端能把自己的平台化做到多好。

15、经常能看到一些案例，一些有技术追求、有热情的工程师，因为技术敏感度和主观能动性都不错，所以工作了五六年之后，逐步开始在自己的公司做一些技术管理相关的事情了。但是，由于他们所在公司的业务并不复杂，也没有技术积累，所以他们自身的技术水平其实并不高，可以说还处于非常初级的阶段，可能面试连阿里 P6 都过不了。这点特别值得大家警醒。

16、关于前端工程师成长，我认为需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。

17、我自己一直奉行着一个观点，不要执着于知识的“临时”实用性。因为我总是感觉，掌握知识越多的人，更喜欢花费时间学习一些暂时可能无法变现的知识，原因有两点：一是其实学知识花费的时间比想象中的要少，这边在纠结它有没有用，那边可能都学完了；二是知识的实用性其实不怎么好判定，比如当年黎曼搞出非欧几何的时候，全世界都觉得纯粹是数学的思维游戏，直到黎曼死了很多年后，相对论出世，黎曼几何有了实际用途。

18、我并不推荐每一个前端工程师都去阅读标准，标准一半是写给实现者，一半是写给使用者，这里本来就有很多知识上的落差，多数时候，MDN 是更好的选择。如果一定要阅读标准，建议从自己做一个极简实现开始，我在浏览器部分，有讲解浏览器相关的知识，在 JavaScript 部分，我还设计了编译原理实验。我想，把它们落到代码上会是一个很好的开始。

19、框架一定是基于某个理念解决了一个被大家诟病已久的问题（圆心说的），学框架，一个是学框架的规则，但更重要的是，你要从宏观理解框架背后的来龙去脉。千万别急着进入细节。

20、还有两张图，一个是 winter 总结的前端工程师的技能模型，一个是我同事总结的前端工程师的职位模型，希望能帮到你（高清图的话，你在视频号私信我吧，微信压缩了图片）。

21、周四，7 月 22 日晚上 8 点，我会在视频号连麦闲鱼的宗心和字节跳动的徐东，和他们聊聊 Flutter。字节和阿里，应该是国内落地 Flutter 最好的公司了吧，他们都是其中的关键角色。如果你对这事感兴趣，那千万不要错过。

22、我是小盖，希望能服务好你。
![Alt text](/static/images/blog/62-1.jpeg)

#### 来源

- [和 winter 聊完前端，我总结了这 20 句掏心窝子的话](https://mp.weixin.qq.com/s/GMrunxdE27IYwwoP6PnIyg)

### 2. A library to smooth out JavaScript logging

![](image-kreqhfm4.png)

#### 来源

- [A library to smooth out JavaScript logging.](https://github.com/AJStacy/Adze)

## 30 seconds of code

### 目标

过滤与给定函数返回 falsy 的对象的键对应的键值对

### 样例输出

```js
omitBy({ a: 1, b: '2', c: 3 }, (x) => typeof x === 'number') // { b: '2' }
```

### 参考实现

```js
const omitBy = (obj, fn) =>
  Object.keys(obj)
    .filter((k) => !fn(obj[k], k))
    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {})
```

## 每日一问

> cookie 和 token 都存放在 header 中，为什么不会劫持 token？

## 每日二问

> 浏览器缓存读取规则
> 可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？

### 上期的答案

#### 每日一问

> 介绍模块化发展历程

可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、`<script type="module">`这几个角度考虑。

模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。

**IIFE**： 使用自执行函数来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。

```js
;(function () {
  return {
    data: [],
  }
})()
```

**AMD**： 使用 requireJS 来编写模块化，特点：依赖必须提前声明好。

```js
define('./index.js', function (code) {
  // code 就是index.js 返回的内容
})
```

**CMD**： 使用 seaJS 来编写模块化，特点：支持动态引入依赖文件。

```js
define(function (require, exports, module) {
  var indexCode = require('./index.js')
})
```

**CommonJS**： nodejs 中自带的模块化。

```js
var fs = require('fs')
```

**UMD**：兼容 AMD，CommonJS 模块化语法。

webpack(require.ensure)：webpack 2.x 版本中的代码分割。

**ES Modules**： ES6 引入的模块化，支持 import 来引入另一个 js 。

```js
import a from 'a'
```

[思维导图](https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map)

#### 每日二问

> call 和 apply 的区别是什么，哪个性能更好一些

![](https://user-images.githubusercontent.com/25839518/76718895-13d75300-6773-11ea-88c2-bb984a209c59.png)

![](https://user-images.githubusercontent.com/25839518/76718908-1b96f780-6773-11ea-8db6-37eea7cb1576.png)

可以看到算法步骤中，apply 多了 CreateListFromArrayLike 的调用，其他的操作几乎是一样的（甚至 apply 仍然多了点操作）。从草案的算法描述来看，call 性能 > apply 性能。
